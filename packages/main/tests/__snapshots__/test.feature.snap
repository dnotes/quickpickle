// Vitest Snapshot v1, https://vitest.dev/guide/snapshot.html

exports[`Feature: Basic Test > Rule: Vitest "todo", "skip", "fails" should respect explodeTags definitions > Scenario: A "@legacy" feature with a "@next" scenario (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Legacy test',
  tags: ["@legacy"]
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Legacy test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Legacy test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Legacy test', () => {

  test.skip('Scenario: Test for legacy (@legacy)', async (context) => {
    let state = await initScenario(context, 'Test for legacy', ['@legacy'], [\`the scenario should be skipped\`]);
    await gherkinStep('Outcome', \`the scenario should be skipped\`, state, 5, 1);
    await afterScenario(state);
  });

  test.skip('Scenario: Test for both (@legacy)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 9, 1, 1);
    await afterScenario(state);
  });



  test('Scenario: Test for both (@next)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 9, 1, 2);
    await afterScenario(state);
  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest "todo", "skip", "fails" should respect explodeTags definitions > Scenario: A "@legacy" rule with a "@next" scenario (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Test',
  tags: []
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Test', () => {

  describe('Rule: Legacy rule', () => {

    const initRuleScenario = async (context, scenario, tags, steps) => {
      let state = await initScenario(context, scenario, tags, steps);
      state.info.rule = 'Legacy rule';

      return state;
    }


    test.skip('Scenario: Test for legacy (@legacy)', async (context) => {
      let state = await initRuleScenario(context, 'Test for legacy', ['@legacy'], [\`the scenario should be skipped\`]);
      await gherkinStep('Outcome', \`the scenario should be skipped\`, state, 7, 1);
      await afterScenario(state);
    });

    test.skip('Scenario: Test for both (@legacy)', async (context) => {
      let state = await initRuleScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
      await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 11, 1, 1);
      await afterScenario(state);
    });



    test('Scenario: Test for both (@next)', async (context) => {
      let state = await initRuleScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
      await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 11, 1, 2);
      await afterScenario(state);
    });


  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest "todo", "skip", "fails" should respect explodeTags definitions > Scenario: A "@next" feature with a "@legacy" scenario (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Next test',
  tags: ["@next"]
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Next test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Next test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Next test', () => {

  test('Scenario: Test for next (@next)', async (context) => {
    let state = await initScenario(context, 'Test for next', ['@next'], [\`the scenario should be run\`]);
    await gherkinStep('Outcome', \`the scenario should be run\`, state, 5, 1);
    await afterScenario(state);
  });

  test.skip('Scenario: Test for both (@legacy)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 9, 1, 1);
    await afterScenario(state);
  });



  test('Scenario: Test for both (@next)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 9, 1, 2);
    await afterScenario(state);
  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest "todo", "skip", "fails" should respect explodeTags definitions > Scenario: A "@next" rule with a "@legacy" scenario (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Test',
  tags: []
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Test', () => {

  describe('Rule: Next rule', () => {

    const initRuleScenario = async (context, scenario, tags, steps) => {
      let state = await initScenario(context, scenario, tags, steps);
      state.info.rule = 'Next rule';

      return state;
    }


    test('Scenario: Test for next (@next)', async (context) => {
      let state = await initRuleScenario(context, 'Test for next', ['@next'], [\`the scenario should be run\`]);
      await gherkinStep('Outcome', \`the scenario should be run\`, state, 7, 1);
      await afterScenario(state);
    });

    test.skip('Scenario: Test for both (@legacy)', async (context) => {
      let state = await initRuleScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
      await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 11, 1, 1);
      await afterScenario(state);
    });



    test('Scenario: Test for both (@next)', async (context) => {
      let state = await initRuleScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
      await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 11, 1, 2);
      await afterScenario(state);
    });


  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest "todo", "skip", "fails" should respect explodeTags definitions > Scenario: A scenario for both "@legacy" and "@next" (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Test',
  tags: []
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Test', () => {

  test.skip('Scenario: Test for both (@legacy)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 5, 1, 1);
    await afterScenario(state);
  });



  test('Scenario: Test for both (@next)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 5, 1, 2);
    await afterScenario(state);
  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest extensions like "skip" should respect explodeTags definitions > Scenario: A "@legacy" feature with a "@next" scenario (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Legacy test',
  tags: ["@legacy"]
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Legacy test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Legacy test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Legacy test', () => {

  test.skip('Scenario: Test for legacy (@legacy)', async (context) => {
    let state = await initScenario(context, 'Test for legacy', ['@legacy'], [\`the scenario should be skipped\`]);
    await gherkinStep('Outcome', \`the scenario should be skipped\`, state, 5, 1);
    await afterScenario(state);
  });

  test.skip('Scenario: Test for both (@legacy)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 9, 1, 1);
    await afterScenario(state);
  });



  test('Scenario: Test for both (@next)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 9, 1, 2);
    await afterScenario(state);
  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest extensions like "skip" should respect explodeTags definitions > Scenario: A "@legacy" rule with a "@next" scenario (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Test',
  tags: []
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Test', () => {

  describe('Rule: Legacy rule', () => {

    const initRuleScenario = async (context, scenario, tags, steps) => {
      let state = await initScenario(context, scenario, tags, steps);
      state.info.rule = 'Legacy rule';

      return state;
    }


    test.skip('Scenario: Test for legacy (@legacy)', async (context) => {
      let state = await initRuleScenario(context, 'Test for legacy', ['@legacy'], [\`the scenario should be skipped\`]);
      await gherkinStep('Outcome', \`the scenario should be skipped\`, state, 7, 1);
      await afterScenario(state);
    });

    test.skip('Scenario: Test for both (@legacy)', async (context) => {
      let state = await initRuleScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
      await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 11, 1, 1);
      await afterScenario(state);
    });



    test('Scenario: Test for both (@next)', async (context) => {
      let state = await initRuleScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
      await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 11, 1, 2);
      await afterScenario(state);
    });


  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest extensions like "skip" should respect explodeTags definitions > Scenario: A "@next" feature with a "@legacy" scenario (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Next test',
  tags: ["@next"]
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Next test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Next test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Next test', () => {

  test('Scenario: Test for next (@next)', async (context) => {
    let state = await initScenario(context, 'Test for next', ['@next'], [\`the scenario should be run\`]);
    await gherkinStep('Outcome', \`the scenario should be run\`, state, 5, 1);
    await afterScenario(state);
  });

  test.skip('Scenario: Test for both (@legacy)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 9, 1, 1);
    await afterScenario(state);
  });



  test('Scenario: Test for both (@next)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 9, 1, 2);
    await afterScenario(state);
  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest extensions like "skip" should respect explodeTags definitions > Scenario: A "@next" rule with a "@legacy" scenario (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Test',
  tags: []
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Test', () => {

  describe('Rule: Next rule', () => {

    const initRuleScenario = async (context, scenario, tags, steps) => {
      let state = await initScenario(context, scenario, tags, steps);
      state.info.rule = 'Next rule';

      return state;
    }


    test('Scenario: Test for next (@next)', async (context) => {
      let state = await initRuleScenario(context, 'Test for next', ['@next'], [\`the scenario should be run\`]);
      await gherkinStep('Outcome', \`the scenario should be run\`, state, 7, 1);
      await afterScenario(state);
    });

    test.skip('Scenario: Test for both (@legacy)', async (context) => {
      let state = await initRuleScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
      await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 11, 1, 1);
      await afterScenario(state);
    });



    test('Scenario: Test for both (@next)', async (context) => {
      let state = await initRuleScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
      await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 11, 1, 2);
      await afterScenario(state);
    });


  });

});
"
`;

exports[`Feature: Basic Test > Rule: Vitest extensions like "skip" should respect explodeTags definitions > Scenario: A scenario for both "@legacy" and "@next" (@explodeTags) 1`] = `
"// Generated by quickpickle
import { test, describe, beforeAll, afterAll } from 'vitest';
import {
  gherkinStep,
  applyHooks,
  getWorldConstructor,
} from 'quickpickle';

let World = getWorldConstructor()

const common = { info: {
  feature: 'Feature: Test',
  tags: []
}};

beforeAll(async () => {
  await applyHooks('beforeAll', common);
});

afterAll(async () => {
  await applyHooks('afterAll', common);
});

const afterScenario = async(state) => {
  await applyHooks('after', state);
}

const initScenario = async(context, scenario, tags, steps) => {
  let state = new World(context, { feature:'Feature: Test', scenario, tags, steps, common, config:{"skipTags":["@legacy"],"explodeTags":[["@legacy","@next"]]}}, undefined);
  await state.init();
  state.common = common;
  state.info.feature = 'Feature: Test';
  state.info.scenario = scenario;
  state.info.tags = [...tags];
  await applyHooks('before', state);

  return state;
}

describe('Feature: Test', () => {

  test.skip('Scenario: Test for both (@legacy)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@legacy'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 5, 1, 1);
    await afterScenario(state);
  });



  test('Scenario: Test for both (@next)', async (context) => {
    let state = await initScenario(context, 'Test for both', ['@next'], [\`the scenario should be both skipped and run\`]);
    await gherkinStep('Outcome', \`the scenario should be both skipped and run\`, state, 5, 1, 2);
    await afterScenario(state);
  });

});
"
`;
